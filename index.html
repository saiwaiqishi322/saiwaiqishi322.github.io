<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-学习笔记（22）订单服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8822%EF%BC%89%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2020-12-05T01:54:36.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8822%EF%BC%89%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/">学习笔记（22）订单服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;create&#x2F;order&quot;)</span><br><span class="line">public Order createOrder(Long skuId,Integer num,Integer memeberId)&#123;</span><br><span class="line">    Order order &#x3D; new Order(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;), skuId, num,</span><br><span class="line">            memeberId);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; rabbitTemplate.convertAndSend(&quot;order-exchange&quot;,&quot;creatOrder&quot;,order);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;user.order.delay.exchange&quot;,&quot;order_delay&quot;,order);</span><br><span class="line"></span><br><span class="line">    return order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建订单成功后，并不直接调用库存系统减库存。而是发到消息队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 1、消息确认机制；</span><br><span class="line">*   1）、如果这个消息收到了，在处理期间，出现了运行时异常，默认认为消息没有被正确处理</span><br><span class="line">*      消息状态unack;队列中感知到有一个unack的消息。</span><br><span class="line">*      unack的消息队列会再次尝试把这个消息发给其他消费者</span><br><span class="line">*</span><br><span class="line">*   2）、我们不要让他认为到底是ack还是unack；手动确认机制；</span><br><span class="line">*      否则：场景；</span><br><span class="line">*          我们收到了消息，并且库存扣了，但是出现了未知的异常，导致消息又重新入队了，</span><br><span class="line">*          这个消息被不断的重复的发给我们；</span><br><span class="line">*        解决：</span><br><span class="line">*          1）、手动ack</span><br><span class="line">*          2）、接口幂等性。在本地维护一个日志表，记录哪些会员哪些商品哪个订单已经减过库存，再来同样的消息就不减了。</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">* 2、手动ack；</span><br><span class="line">*  1)、开启手动ack；spring.rabbitmq.listener.simple.acknowledge-mode&#x3D;manual</span><br><span class="line">*  2）、</span><br><span class="line">*  public void listener()&#123;</span><br><span class="line">*      try&#123;</span><br><span class="line">*          &#x2F;&#x2F;处理消息，回复成功。</span><br><span class="line">*          channal.basicAck();</span><br><span class="line">*      &#125;catch(Exception e)&#123;</span><br><span class="line">*          &#x2F;&#x2F;拒绝消息。</span><br><span class="line">*          channal.basicNack&#x2F;Reject( requeue:true);</span><br><span class="line">*      &#125;</span><br><span class="line">*  &#125;</span><br><span class="line">&#x2F;&#x2F;类似于事务</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>死信队列实现定时关单</p>
<p><img src="https://img-blog.csdnimg.cn/20201203163324260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 当信息确认完成以后下一步要提交订单。我们必须做防重复验证【接口幂等性设计】；</span><br><span class="line"> * 1）、以前利用防重的令牌以后。</span><br><span class="line"> * 接口幂等性设计：</span><br><span class="line"> *    select：</span><br><span class="line"> *    insert&#x2F;delete&#x2F;update【幂等性设计】；</span><br><span class="line"> *</span><br><span class="line"> * 2）、数据层面怎么幂等？可用数据库的锁机制保证在数据库层面多次请求幂等</span><br><span class="line"> *    insert();【如果id不是自增，传入id】</span><br><span class="line"> *    delete();【在数据层如果带id删除，幂等操作】</span><br><span class="line"> *    update();【乐观锁】  update set stock&#x3D;stock-1,version&#x3D;version+1 where skuId&#x3D;1 and version&#x3D;1</span><br><span class="line"> *</span><br><span class="line"> * 3）、业务层面；</span><br><span class="line"> *    分布式锁_【令牌防重】。 order:member:1;</span><br><span class="line"> *    分布式锁并发下单；</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @param accessToken</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@ApiOperation(&quot;订单确认&quot;)</span><br><span class="line">@GetMapping(&quot;&#x2F;confirm&quot;)</span><br><span class="line">public CommonResult confirmOrder(@RequestParam(&quot;accessToken&quot;) String accessToken)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;0、检查用户是否存在</span><br><span class="line">    String memberJson &#x3D; redisTemplate.opsForValue().get(SysCacheConstant.LOGIN_MEMBER + accessToken);</span><br><span class="line">    if(StringUtils.isEmpty(accessToken)||StringUtils.isEmpty(memberJson))&#123;</span><br><span class="line">        CommonResult failed &#x3D; new CommonResult().failed();</span><br><span class="line">        failed.setMessage(&quot;用户未登录，请先登录&quot;);</span><br><span class="line">        &#x2F;&#x2F;用户未登录</span><br><span class="line">        return failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1、登录的用户</span><br><span class="line">    Member member &#x3D; JSON.parseObject(memberJson, Member.class);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回如下数据；</span><br><span class="line">     * 1、当前用户的可选地址列表</span><br><span class="line">     * 2、当前购物车选中的商品信息</span><br><span class="line">     * 3、可用的优惠卷信息</span><br><span class="line">     * 4、支付、配送、发票方式信息</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;dubbo的RPC隐式传参；setAttachment保存一下下一个远程服务需要的参数</span><br><span class="line">    RpcContext.getContext().setAttachment(&quot;accessToken&quot;,accessToken);</span><br><span class="line">    &#x2F;&#x2F;调用下一个远程服务</span><br><span class="line">    OrderConfirmVo confirm &#x3D; orderService.orderConfirm(member.getId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return new CommonResult().success(confirm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般不做令牌的防重幂等，发请求时才做令牌防重幂等，如果收到http请求，才做令牌幂等。</p>
<p>如果现在底层就是调了一个insert方法，没有必要做幂等判断，只要请求能进来调service，就认为前端已经过滤掉幂等。而在业务里还要考虑幂等，做数据库层面的幂等</p>
<p>分布式锁_【令牌防重】。 order:member:1; 第一次拿到，第二次拿不到</p>
<p>分布式锁并发下单；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;dubbo的RPC隐式传参；setAttachment保存一下下一个远程服务需要的参数</span><br><span class="line">RpcContext.getContext().setAttachment(&quot;accessToken&quot;,accessToken);</span><br><span class="line">&#x2F;&#x2F;调用下一个远程服务</span><br><span class="line">OrderConfirmVo confirm &#x3D; orderService.orderConfirm(member.getId());</span><br><span class="line">public OrderConfirmVo orderConfirm(Long id) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1、获取上一步隐式传参带来的accessToken</span><br><span class="line">    String accessToken &#x3D; RpcContext.getContext().getAttachment(&quot;accessToken&quot;);</span><br><span class="line">    OrderConfirmVo confirmVo &#x3D; new OrderConfirmVo();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;会员收货地址</span><br><span class="line">    confirmVo.setAddresses(memberService.getMemberAddress(id));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置优惠卷信息</span><br><span class="line">    confirmVo.setCoupons(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;CartItem&gt; cartItems &#x3D; cartService.getCartItemForOrder(accessToken);</span><br><span class="line">    &#x2F;&#x2F;设置购物项</span><br><span class="line">    confirmVo.setItems(cartItems);</span><br></pre></td></tr></table></figure>

<p>防重令牌的设计：</p>
<p><img src="https://img-blog.csdnimg.cn/20201203163408587.png#pic_center" alt="在这里插入图片描述"></p>
<p>值用set，一个集合，里面有各种令牌，用一个set集合，删一个。</p>
<p>这样redis很清晰，key只有一个，点进去是所有令牌。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203163546284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203163556574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201203163606339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201203163620852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201203163636643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="订单幂等性"><a href="#订单幂等性" class="headerlink" title="订单幂等性"></a>订单幂等性</h1><p>第一种：创建订单要提交上次的token，防重令牌</p>
<p>第二种：依赖数据库，保存订单，订单数据整理好，保存订单也是远程服务，远程服务可能失败，dubbo尝试3次，dubbo以为没保存，订单可能保存3遍，订单表里同一单号有3个，得益于数据库幂等性，订单生产订单号，同一个订单号只能一次insert，订单号加一个唯一索引，再保存相同订单号，报错。</p>
<p>数据库幂等即保存的时候。幂等字段需要唯一索引。<br><img src="https://img-blog.csdnimg.cn/20201203163738718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>双重幂等：</p>
<p>首先，令牌能进来，肯定是一次请求。</p>
<p>然后要保存到数据库，数据库加幂等，好处万一令牌用着用着有问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8822%EF%BC%89%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/" data-id="ckib1p4c5000b40u1bht09k31" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（21）消息队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8821%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2020-12-05T01:53:59.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8821%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">学习笔记（21）消息队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p><img src="https://img-blog.csdn.net/20170730143301053" alt="img"></p>
<p>上表有一处问题，其中rabbitMQ也支持分布式。</p>
<p>本项目选rabbitMQ的原因：1 性能高 2 支持高级队列协议</p>
<p><img src="https://img-blog.csdnimg.cn/20201203163036786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>每个服务建立一个长TCP连接，连接里有通道。</p>
<p>连接好处，一但服务器突然宕机，MQ能及时感知，不再给该服务器发消息。</p>
<p>在MQ里开小MQ，每个Vhost是隔离的，相当于一个镜像，另一个镜像。</p>
<p>direct是点对点模式，其它是发布订阅模式。</p>
<p>headers和topic模式一样，topic决定发给谁由路由件决定，但headers模式由消息头里某个字段决定，性能低，还需要拿到消息头的某个字段分析。</p>
<p>ACK模式：拿到队列中的消息后并移除。</p>
<p>NACK模式：拿到队列中的消息不移除。<br><img src="https://img-blog.csdnimg.cn/20201203163201286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203163210847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>自动注入rabbitTemplateConfigurer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用RabbitMQ的步骤</span><br><span class="line"> * 1）、导入amqp-starter</span><br><span class="line"> * 2）、编写自动配置 RabbitAutoConfiguration；RabbitProperties</span><br><span class="line"> * 3）、开启RabbitMQ功能</span><br><span class="line"> *</span><br><span class="line"> * 自动配置了RabbitTemplate</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 自定义RabbitMQ的MessageConverter</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">public MessageConverter messageConverter()&#123;</span><br><span class="line">    return new Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * 方法上可以写以下参数</span><br><span class="line">     * 1、org.springframework.amqp.core.Message：既能获取到消息的内容字节，还能获取到消息的其他属性</span><br><span class="line">     * 2、 User user：如果明确我们这个队列以后都是这个类型对象，直接写这个类型参数</span><br><span class="line">     * 3、com.rabbitmq.client.Channel：通道；</span><br><span class="line">     *</span><br><span class="line">     * 以上无任何顺序，也无数量限制</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#x2F;&#x2F;    @RabbitListener(queues &#x3D; &#123;&quot;world&quot;&#125;)</span><br><span class="line">&#x2F;&#x2F;    public void receiveUserMessage(Message message, User user, Channel channel) throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;收到的消息是：&quot;+message.getClass());</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;byte[] body &#x3D; message.getBody();</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;MessageProperties messageProperties &#x3D; message.getMessageProperties();</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;收到的消息是：&quot;+user);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;拒绝：可以把消息拒绝调，让 rabbitmq 再发给别人。</span><br><span class="line">&#x2F;&#x2F;        channel.basicReject(message.getMessageProperties().getDeliveryTag(),true);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">AmqpAdmin自动创建队列，交换机，绑定关系</span><br><span class="line">&#x2F;&#x2F;通过配置类自动创建队列</span><br><span class="line">@Configuration</span><br><span class="line">public class MyRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果RabbitMq没有这个队列、交换机、绑定关系会自动创建。</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue()&#123;</span><br><span class="line">        return new Queue(&quot;order-queue&quot;,true,false,false,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Exchange orderExchange()&#123;</span><br><span class="line">        return new DirectExchange(&quot;order-exchange&quot;,true,false,null);</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderbinding()&#123;</span><br><span class="line">        return new Binding(&quot;order-queue&quot;, Binding.DestinationType.QUEUE,</span><br><span class="line">                &quot;order-exchange&quot;,&quot;creatOrder&quot;,null);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 其他都一样。。。</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8821%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" data-id="ckib1p4c4000a40u192t6b6f9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（20）分布式事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2020-12-05T01:53:22.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">学习笔记（20）分布式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p>分布式事务原因：服务太多，这个操作那个表，这个操作这个表，这个操作这个数据库，那个操作那个数据库，两个表一起联动，它要滚，那么它也跟着要滚</p>
<p><img src="https://img-blog.csdnimg.cn/20201203162724435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>干完活后把信息发到消息队列，容忍一段时间的不一致。</p>
<p>分布式事务的两个原因；</p>
<p>服务节点分布过多</p>
<p>资源（db）阶段分散</p>
<p>其中有个原因是因为微服务太多。太多团队一个人维护几个微服务，过度设计。</p>
<p>微服务多就会引出分布式事务，这个时候不会建议任何一种分布式事务解决方案，而是将这些服务聚合成一个<strong>单机服务</strong>，使用数据库的本地事务。因为无论什么方案都会增加系统的复杂度和不可靠性。</p>
<p>单机服务：例如用户和订单天天互相操作，就把用户和订单写一起。用户表，订单表放在一起。</p>
<p>分布式事务应该是我们去<strong>积极避免</strong>的，而不是去努力拥抱的。</p>
<p>一句话，<strong>能不用就不用</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" data-id="ckib1p4c3000940u1h8ib8keb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（19）购物车" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8819%EF%BC%89%E8%B4%AD%E7%89%A9%E8%BD%A6/" class="article-date">
  <time datetime="2020-12-05T01:52:40.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8819%EF%BC%89%E8%B4%AD%E7%89%A9%E8%BD%A6/">学习笔记（19）购物车&#34;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p>购物车有两种情况：</p>
<p> 在线购物车；</p>
<p> 离线购物车；</p>
<p>离线购物车：</p>
<p>只要每次看购物车。都有一个<strong>user-key=uuid</strong>；如果这个user-key丢了，购物车就没了。</p>
<p>如果我们要看购物车肯定会带上这个user-key的cookie；如果有就用自带的，没有就新建一个以后用这个。</p>
<p>登录以后离线的和在线的合并了，并且清空了离线购物车里面的数据。</p>
<p>京东怎么做购物车？</p>
<p> 购物车有一个cookie对应的key关联，即使没有登录也有，登录以后进行购物车合并，合并完成后删除购物车数据；该系统也设计离线在线购物车。</p>
<p>离线购物车：永远用 cart-key=uuid；购物车数据都在redis中提升系统的性能。cart:temp: uuid；</p>
<p>在线购物车：cart:1={};放在redis中；cart:user:1；</p>
<p><img src="https://img-blog.csdnimg.cn/20201203161817958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201203161828636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>抽取购物项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private BigDecimal totalPrice;&#x2F;&#x2F;当前购物项总价</span><br><span class="line">&#x2F;&#x2F;算价格用BigDecimal ，否则带小数的运算有问题</span><br></pre></td></tr></table></figure>

<p>用hash存储，key为skuid，value为json字符串。</p>
<p>想改1号商品数量，拿Cart:user：1 查到整个购物车，然后get出1号商品，得到json字符串，反序列化成CartItem,把CartItem中的数量改成5，然后json重新覆盖。</p>
<p>用k-v最大的另一个好处，可以多加一个字段checked ，value是数组，这样不用遍历购物车就可获取选中商品。</p>
<p>最终购物车的结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20201203161937265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>reddison 的分布式集合：</p>
<p>做分布式一定要序列化接口</p>
<p>测试Reddsion：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void userRedissonMap()&#123;</span><br><span class="line">    RMap&lt;String, String&gt; cart &#x3D; redissonClient.getMap(&quot;cart&quot;);</span><br><span class="line">    CartItem item &#x3D; new CartItem();</span><br><span class="line">    item.setPrice(new BigDecimal(&quot;12.98&quot;));</span><br><span class="line">    item.setSkuId(1L);</span><br><span class="line">    item.setCount(1);</span><br><span class="line">    String s &#x3D; JSON.toJSONString(item);</span><br><span class="line">    cart.put(&quot;2&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试后redis如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201203162010669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据accessToken查询用户信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Member getMemberByAccessToken(String accessToken)&#123;</span><br><span class="line">    String userJson &#x3D; redisTemplate.opsForValue().get(SysCacheConstant.LOGIN_MEMBER + accessToken);</span><br><span class="line">    return JSON.parseObject(userJson, Member.class);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;系统中存用户的json</span><br><span class="line">&#x2F;&#x2F;经常要用，封装成组件</span><br><span class="line">@Component</span><br><span class="line">public class MemberComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public UserCartKey getCartKey(String accessToken, String cartKey)&#123;</span><br><span class="line">        UserCartKey userCartKey &#x3D; new UserCartKey();</span><br><span class="line">        Member member &#x3D; null;</span><br><span class="line">        if(!StringUtils.isEmpty(accessToken))&#123;</span><br><span class="line">            member &#x3D; getMemberByAccessToken(accessToken);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(member!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;获取到了在线用户；用户登录用这个</span><br><span class="line">            userCartKey.setLogin(true);</span><br><span class="line">            userCartKey.setUserId(member.getId());</span><br><span class="line">            userCartKey.setFinalCartKey(CartConstant.USER_CART_KEY_PREFIX+member.getId());</span><br><span class="line">            return userCartKey;</span><br><span class="line">        &#125;else if(!StringUtils.isEmpty(cartKey))&#123;</span><br><span class="line">            &#x2F;&#x2F;用户有临时的用这个</span><br><span class="line">            userCartKey.setLogin(false);</span><br><span class="line">            userCartKey.setFinalCartKey(CartConstant.TEMP_CART_KEY_PREFIX+cartKey);</span><br><span class="line">            return userCartKey;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;用户既没有登录也没有零时购物车</span><br><span class="line">            String replace &#x3D; UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">            userCartKey.setLogin(false);</span><br><span class="line">            userCartKey.setFinalCartKey(CartConstant.TEMP_CART_KEY_PREFIX+replace);</span><br><span class="line">            userCartKey.setTempCartKey(replace);</span><br><span class="line"></span><br><span class="line">            return userCartKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据accessToken查询用户信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Member getMemberByAccessToken(String accessToken)&#123;</span><br><span class="line">        String userJson &#x3D; redisTemplate.opsForValue().get(SysCacheConstant.LOGIN_MEMBER + accessToken);</span><br><span class="line">        return JSON.parseObject(userJson, Member.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几种购物车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String oldCartKey &#x3D; CartConstant.TEMP_CART_KEY_PREFIX+cartKey;</span><br><span class="line">String userCartKey &#x3D; CartConstant.USER_CART_KEY_PREFIX+id.toString();</span><br><span class="line">if(member!&#x3D;null)&#123;</span><br><span class="line">    &#x2F;&#x2F;获取到了在线用户；用户登录用这个</span><br><span class="line">    userCartKey.setLogin(true);</span><br><span class="line">    userCartKey.setUserId(member.getId());</span><br><span class="line">    userCartKey.setFinalCartKey(CartConstant.USER_CART_KEY_PREFIX+member.getId());</span><br><span class="line">    return userCartKey;</span><br><span class="line">&#125;else if(!StringUtils.isEmpty(cartKey))&#123;</span><br><span class="line">    &#x2F;&#x2F;用户有临时的用这个</span><br><span class="line">    userCartKey.setLogin(false);</span><br><span class="line">    userCartKey.setFinalCartKey(CartConstant.TEMP_CART_KEY_PREFIX+cartKey);</span><br><span class="line">    return userCartKey;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    &#x2F;&#x2F;用户既没有登录也没有零时购物车</span><br><span class="line">    String replace &#x3D; UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    userCartKey.setLogin(false);</span><br><span class="line">    userCartKey.setFinalCartKey(CartConstant.TEMP_CART_KEY_PREFIX+replace);</span><br><span class="line">    userCartKey.setTempCartKey(replace);</span><br><span class="line"></span><br><span class="line">    return userCartKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>购物车postman测试：<br><img src="https://img-blog.csdnimg.cn/20201203162333555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162342941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162351248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162359503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162408441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162418336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162426234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162436585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>直接写类似于双写，写map其实是在写缓存。</p>
<p>回写，把map写完后，开个异步任务，写缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自动续期 ，防止购物车撑爆</span><br><span class="line">&#x2F;&#x2F;redisTemplate.expire(finalCartKey,30L, TimeUnit.DAYS);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201203162607217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201203162616532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162624645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201203162632316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>HashSet改成LinkedHashSet,也是有序的了，添加物品时有序，如上图的1,2,3,4各行按操作顺序排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除购物车先维护购物车状态，再删json。若反，删除了json也没有了，再改json数据有问题</span><br><span class="line">@Override</span><br><span class="line">public CartResponse delCartItem(Long skuId, String cartKey, String accessToken) &#123;</span><br><span class="line"></span><br><span class="line">    UserCartKey userCartKey &#x3D; memberComponent.getCartKey(accessToken, cartKey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String finalCartKey &#x3D; userCartKey.getFinalCartKey();</span><br><span class="line">    &#x2F;&#x2F;维护购物项的checked状态</span><br><span class="line">    checkItem(Arrays.asList(skuId),false,finalCartKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取购物车删除购物项</span><br><span class="line">    RMap&lt;String, String&gt; map &#x3D; redissonClient.getMap(finalCartKey);</span><br><span class="line">    map.remove(skuId.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;整个购物车再返回出去</span><br><span class="line">    CartResponse cartResponse &#x3D; listCart(cartKey, accessToken);</span><br><span class="line">    return cartResponse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）、购物车数据保存在redis中，使用分布式集合；【redisson.getMap】</p>
<p>2）、用户对于购物车的所有操作，都需要传入cart-key，如果用户登录了，还需要传入token</p>
<p>购物车需要提供的所有方法；</p>
<p>1）、添加到购物车</p>
<p>2）、修改购物项</p>
<p>3）、删除购物项</p>
<p>4）、选中/选不中购物项</p>
<p>5）、返回整个购物车</p>
<p>6）、点击去结算-获取购物车中需要结算的数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8819%EF%BC%89%E8%B4%AD%E7%89%A9%E8%BD%A6/" data-id="ckib1p4c2000840u18fbz0m0z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（18）单点登录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8818%EF%BC%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" class="article-date">
  <time datetime="2020-12-05T01:52:03.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8818%EF%BC%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">学习笔记（18）单点登录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20201203160741996.png#pic_center" alt="在这里插入图片描述"></p>
<p>核心：拿cookie标识用户是否登录。</p>
<p>cookie为啥一会放在url地址，一会又传回来？</p>
<p>因为不同域名下的cookie不能共享，需要把认证服务器下登陆过的标志要交给你，只能通过url地址方式放在后边，自己处理后保存。</p>
<p>由于不同域名之间cookie没法共享</p>
<p>认证服务器只能将自己旗下的登录过的用户的标识以url地址参数的方式交给另外一个域名。让这个域名对应的服务器，自己妥善保存这个cookie信息。</p>
<p>之前社交登录查用户信息是通过acceaaToken查，accessToken如何传过来？社交登录一上来，会返回code，code就是在url后面。</p>
<p>总结：跨域名共享数据我们只能通过url地址携带。</p>
<p>我们不要把无意义的uuid放进去。我们把token制作成jwt，全局传输jwt。</p>
<p>京东，离线了，打开之后仍然可以看见名字。排除上次缓存查找到的，即禁用缓存还可以看见用户信息怎办？用令牌jwt</p>
<p>返回令牌，自己想办法保存好令牌，以后所有的请求都在参数上带上令牌，也可以用jwt作为令牌，令牌里面的负载不用连远程服务器，自己都能解析出来；</p>
<p><img src="https://img-blog.csdnimg.cn/20201203160916948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>为了省流量，手机端发请求，不需要全令牌带上，只需解析jwt中的accessToken即可。只耗1kb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 这个方法是系统用的登录方法，只需要登录成功统一返回token即可</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(&quot;&#x2F;applogin&quot;)</span><br><span class="line">public CommonResult loginForGmall(@RequestParam(&quot;username&quot;) String username,</span><br><span class="line">                                  @RequestParam(&quot;password&quot;) String password)&#123;</span><br><span class="line">    Member member &#x3D; memberService.login(username,password);</span><br><span class="line"></span><br><span class="line">    if(member &#x3D;&#x3D; null)&#123;</span><br><span class="line">        &#x2F;&#x2F;用户没有</span><br><span class="line">        CommonResult result &#x3D; new CommonResult().failed();</span><br><span class="line">        result.setMessage(&quot;账号密码不匹配，请重新登录&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        String token &#x3D; UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">        String memberJson &#x3D; JSON.toJSONString(member);</span><br><span class="line">        redisTemplate.opsForValue()</span><br><span class="line">                .set(SysCacheConstant.LOGIN_MEMBER+token,memberJson,</span><br><span class="line">                        SysCacheConstant.LOGIN_MEMBER_TIMEOUT, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        LoginResponseVo vo &#x3D; new LoginResponseVo();</span><br><span class="line">        BeanUtils.copyProperties(member,vo);</span><br><span class="line">        &#x2F;&#x2F;设置访问令牌</span><br><span class="line">        vo.setAccessToken(token);</span><br><span class="line">        return new CommonResult().success(vo);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8818%EF%BC%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" data-id="ckib1p4c1000740u16p706ib9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（17）社交登录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8817%EF%BC%89%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95/" class="article-date">
  <time datetime="2020-12-05T01:51:27.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8817%EF%BC%89%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95/">学习笔记（17）社交登录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<h2 id="社交登录的步骤"><a href="#社交登录的步骤" class="headerlink" title="社交登录的步骤"></a>社交登录的步骤</h2><p>1）、给页面放一个社交登录按钮，点击地址是微博登录</p>
<p>2）、用户只要授权通过了，会自动跳转到我们指定的<a target="_blank" rel="noopener" href="http://www.gulishop.com/success%EF%BC%8C%E4%BC%9A%E7%BB%99url%E5%90%8E%E9%9D%A2%E5%B8%A6%E4%B8%80%E4%B8%AAcode=xxxxxxxx">http://www.gulishop.com/success，会给url后面带一个code=xxxxxxxx</a>**</p>
<p>3）、拿到这个code发送请求换取access_token即可。<br>4）、拿到access_token可以调用所有的开放api；</p>
<p><a target="_blank" rel="noopener" href="https://open.weibo.com/apps/771268000/privilege">https://open.weibo.com/apps/771268000/privilege</a></p>
<p>可以将用户的信息都保存自己的网站。</p>
<p>核心：</p>
<p>code一次性的，只要用过就作废。</p>
<p>access_token：是固定的，一段时间完全固定。</p>
<p>uid：是永远固定的。</p>
<p>我们自己的系统如何标识唯一用户，就是使用社交网站的uid。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203160651426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8817%EF%BC%89%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95/" data-id="ckib1p4c0000640u19dkcegi0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（16）多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2020-12-05T01:50:41.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/">学习笔记（16）多线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 数据库（商品的基本信息表、商品的属性表、商品的促销表）和  es(info&#x2F;attr&#x2F;sale)</span><br><span class="line"> *</span><br><span class="line"> * 查加缓存</span><br><span class="line"> * 1、第一次查。肯定长。</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public EsProduct productInfo2(Long id)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;,threadPoolExecutor).whenComplete((r,e)-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;处理结果&quot;+r);</span><br><span class="line">        System.out.println(&quot;处理异常&quot;+e);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;1、商品基本数据（名字介绍等） 100ms   异步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2、商品的属性数据  300ms</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;查属性信息&quot;);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3、商品的营销数据  SmsService 1s 500ms</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;查营销信息&quot;);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    &#x2F;&#x2F;4、商品的配送数据  WuliuService 2s  700ms</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;查配送信息&quot;);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    &#x2F;&#x2F;5、商品的增值服务数据  SaleService  1s 1s</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;查增值信息&quot;);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;otherThreadPoolExecutor.submit()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上： 8s 2.5s； 需要速度快。 开启异步化 最多1s，取决最长的服务调用。<br>高并发系统的优化<br>1、加缓存<br>2、开异步</p>
<p><img src="https://img-blog.csdnimg.cn/20201203160219200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>10万线程*5 = 50万，机器必炸，机器内存耗尽。</p>
<p>解决：使用线程池，不自己new线程，线程池去开线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;使用线程池控制系统资源，防止线程资源耗尽</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;线程数调多少？cpu内核数。实际：必须通过压力测试来寻找系统最佳参数，</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;压力。峰值流量*3。100,8,9；  16-8   cpu^3</span><br><span class="line">&#x2F;&#x2F;        ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;默认的线程池里面的Queue是一个无界队列。</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;极限情况。线程全部放进队列。无界队列撑爆内存。</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;ThreadPool：拒绝策略。四种：自己总结;默认出异常。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;线程池任务准备....&quot;);</span><br><span class="line">&#x2F;&#x2F;        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;            Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;                System.out.println(&quot;当前线程开始:&quot; + Thread.currentThread());</span><br><span class="line">&#x2F;&#x2F;                try &#123;</span><br><span class="line">&#x2F;&#x2F;                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;                &#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;                int j &#x3D; 10&#x2F;0;</span><br><span class="line">&#x2F;&#x2F;                System.out.println(&quot;当前线程结束:&quot; + Thread.currentThread());</span><br><span class="line">&#x2F;&#x2F;            &#125;);</span><br><span class="line">&#x2F;&#x2F;            &#x2F;&#x2F;给线程池提交任务</span><br><span class="line">&#x2F;&#x2F;            threadPool.submit(thread);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;所有任务都已提交....&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">任务交给线程池，出现异常无法感知</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务交给线程池，出现异常无法感知。</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#x2F;&#x2F;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">&#x2F;&#x2F;        ExecutorService pool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;主线程......&quot;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        CompletableFuture&lt;String&gt; future &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(&quot;当前线程开始：&quot;+Thread.currentThread());</span><br><span class="line">&#x2F;&#x2F;            String uuid &#x3D; UUID.randomUUID().toString();</span><br><span class="line">&#x2F;&#x2F;            System.out.println(&quot;当前线程结束：&quot;+Thread.currentThread());</span><br><span class="line">&#x2F;&#x2F;            return uuid;</span><br><span class="line">&#x2F;&#x2F;        &#125;, pool).thenApply((r)-&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;            try &#123;</span><br><span class="line">&#x2F;&#x2F;                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">&#x2F;&#x2F;            &#125;catch (Exception e)&#123;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(&quot;上一步的结果是：&quot;+r);</span><br><span class="line">&#x2F;&#x2F;            return r.replace(&quot;-&quot;,&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F;        &#125;).whenComplete((r,e)-&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;            try &#123;</span><br><span class="line">&#x2F;&#x2F;                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">&#x2F;&#x2F;            &#125;catch (Exception e1)&#123;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(&quot;最终结果....&quot;+r);</span><br><span class="line">&#x2F;&#x2F;        &#125;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;主线程结束......&quot;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"> public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService pool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; f1 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;查询商品基本数据...&quot;);</span><br><span class="line">            return &quot;小米&quot;;</span><br><span class="line">        &#125;, pool)</span><br><span class="line">                .whenComplete((r,e)-&gt;&#123;</span><br><span class="line">                    System.out.println(&quot;结果是：&quot;+r);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; f2 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;查询商品属性数据...&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;, pool).whenComplete((r,e)-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;结果是：&quot;+r);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; f3 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;查询商品营销数据...&quot;);</span><br><span class="line">            return &quot;满199减100&quot;;</span><br><span class="line">        &#125;, pool).whenComplete((r,e)-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;结果是：&quot;+r);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;所有人都执行完</span><br><span class="line">        CompletableFuture&lt;Void&gt; allOf &#x3D; CompletableFuture.allOf(f1, f2, f3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Void aVoid &#x3D; allOf.get();</span><br><span class="line">       &#x2F;&#x2F; allOf.join();&#x2F;&#x2F;线程插队。让所有线程执行完</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;所有人都完成了....&quot;+f1.get());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; CompletableFuture.anyOf(f1,f2,f3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;以后异步任务的编程模式。。。。。</span><br><span class="line">        &#x2F;&#x2F;CompletableFuture.supplyAsync(()-&gt;&#123;&#125;,pool).whenComplete()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;以后异步任务的编程模式。。。。。</span><br><span class="line">    &#x2F;&#x2F;CompletableFuture.supplyAsync(()-&gt;&#123;&#125;,pool).whenComplete()</span><br></pre></td></tr></table></figure>

<p>核心业务：商品对数据的修改，下订单，可以用异步拆解提交给线程池。</p>
<p>非核心业务：发邮件，发短信，记录日志，批量计算等交给非核心线程池，比如注册成功发邮件。</p>
<p>性能不行的时候进行释放非核心业务池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ThreadPoolConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;gmall.pool.coreSize&#125;&quot;)</span><br><span class="line">    private Integer coreSize;</span><br><span class="line">    private Integer maximumPoolSize;</span><br><span class="line">    private Integer queueSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean(&quot;mainThreadPoolExecutor&quot;)</span><br><span class="line">    public ThreadPoolExecutor mainThreadPoolExecutor(PoolProperties poolProperties)&#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *   public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">         *                               int maximumPoolSize,</span><br><span class="line">         *                               long keepAliveTime,</span><br><span class="line">         *                               TimeUnit unit,</span><br><span class="line">         *                               BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">         *                               RejectedExecutionHandler handler) &#123;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        LinkedBlockingDeque&lt;Runnable&gt; deque &#x3D; new LinkedBlockingDeque&lt;&gt;(poolProperties.getQueueSize());</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(poolProperties.getCoreSize(),</span><br><span class="line">                poolProperties.getMaximumPoolSize(), 10,</span><br><span class="line">                TimeUnit.MINUTES, deque);</span><br><span class="line"></span><br><span class="line">        return threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;otherThreadPoolExecutor&quot;)</span><br><span class="line">    public ThreadPoolExecutor otherThreadPoolExecutor(PoolProperties poolProperties)&#123;</span><br><span class="line">        LinkedBlockingDeque&lt;Runnable&gt; deque &#x3D; new LinkedBlockingDeque&lt;&gt;(poolProperties.getQueueSize());</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(poolProperties.getCoreSize(),</span><br><span class="line">                poolProperties.getMaximumPoolSize(), 10,</span><br><span class="line">                TimeUnit.MINUTES, deque);</span><br><span class="line"></span><br><span class="line">        return threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置组件两种方式，核心线程和非核心线程应为两种配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#  private Integer coreSize;</span><br><span class="line">#    private Integer maximumPoolSize;</span><br><span class="line">#    private Integer queueSize;</span><br><span class="line">#如何把一个组件做成可配置的</span><br><span class="line">#1)、组件放在容器中</span><br><span class="line">#2）、组件的核心参数绑定成配置文件即可</span><br><span class="line">gmall.pool.coreSize&#x3D;8</span><br><span class="line">gmall.pool.maximumPoolSize&#x3D;100</span><br><span class="line">gmall.pool.queueSize&#x3D;1000000</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;gmall.pool.coreSize&#125;&quot;)</span><br><span class="line">    private Integer coreSize;</span><br><span class="line">    private Integer maximumPoolSize;</span><br><span class="line">    private Integer queueSize;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ProductItemController &#123;</span><br><span class="line"></span><br><span class="line">    @Reference</span><br><span class="line">    ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Qualifier(&quot;mainThreadPoolExecutor&quot;)</span><br><span class="line">    @Autowired</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    @Qualifier(&quot;otherThreadPoolExecutor&quot;)</span><br><span class="line">    @Autowired</span><br><span class="line">    ThreadPoolExecutor otherThreadPoolExecutor;</span><br></pre></td></tr></table></figure>

<p>监控线程池状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ThreadPoolController &#123;</span><br><span class="line">    @Qualifier(&quot;mainThreadPoolExecutor&quot;)</span><br><span class="line">    @Autowired</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;thread&#x2F;status&quot;)</span><br><span class="line">    public Map threadPoolStatue()&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;ActiveCount&quot;,threadPoolExecutor.getActiveCount());</span><br><span class="line">        map.put(&quot;CorePoolSize&quot;,threadPoolExecutor.getCorePoolSize());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       return  map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201203160353225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckib1p4bz000540u1duqcbg69" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（15）商品详情" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85/" class="article-date">
  <time datetime="2020-12-05T01:49:55.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85/">学习笔记（15）商品详情</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p>商品详情是一个高并发访问的功能</p>
<p>我们需要考虑<strong>缓存</strong>、考虑性能、考虑机器压力。</p>
<p>京东商城：一个请求过去，所有数据都来了。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203155805895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1）、服务拆分查询</p>
<p> 查询商品基础信息</p>
<p> 查询sku组合信息</p>
<p> 点击sku组合查询商品基础信息+sku信息（特别是库存）</p>
<p> 商品的所有属性信息</p>
<p> 大数据不可以联表（数据太多）。</p>
<p> 1）、禁用联表。</p>
<p> 2）、MySQL表有极限。大数据表分表；</p>
<p>2）、做好容错。</p>
<p> 如果sku组合查询库存以及售价出现问题，返回兜底数据。</p>
<p>分表：<br><img src="https://img-blog.csdnimg.cn/20201203155835867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>数据量更大时，还会采用分库：</p>
<p><img src="https://img-blog.csdnimg.cn/20201203155919589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>sahrding-jdbd 能分表，用其存数据，但是不能用其查数据库，数据异构的统一解决方案 es</p>
<p>如何知道一号商品有哪些属性且对应的值是哪些？</p>
<p>用es检索一号商品，再在es的属性索引下检索一号商品有哪些属性，es还有值索引，再去检索es对应的哪些值。es只需要做好集群，所有数据进入es。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203155948761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>三写：</p>
<p>1）、给数据库存东西</p>
<p>1）、给缓存一份（用id查的快）</p>
<p>2）、给es一份（用其他字段查的快）</p>
<p>复杂查询，es先查出商品id，再直接从缓存中拿。</p>
<p>商品详情页请求：<a target="_blank" rel="noopener" href="http://localhost:8081/detail/28">http://localhost:8081/detail/28</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public EsProduct productAllInfo(Long id) &#123;</span><br><span class="line">      EsProduct esProduct &#x3D; null;</span><br><span class="line">      &#x2F;&#x2F;按照id查出商品</span><br><span class="line">      SearchSourceBuilder builder &#x3D; new SearchSourceBuilder();</span><br><span class="line">      builder.query(QueryBuilders.termQuery(&quot;id&quot;,id));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Search build &#x3D; new Search.Builder(builder.toString())</span><br><span class="line">              .addIndex(EsConstant.PRODUCT_ES_INDEX)</span><br><span class="line">              .addType(EsConstant.PRODUCT_INFO_ES_TYPE)</span><br><span class="line">              .build();</span><br><span class="line">      try &#123;</span><br><span class="line">          SearchResult execute &#x3D; jestClient.execute(build);</span><br><span class="line"></span><br><span class="line">          List&lt;SearchResult.Hit&lt;EsProduct, Void&gt;&gt; hits &#x3D; execute.getHits(EsProduct.class);</span><br><span class="line">          esProduct &#x3D; hits.get(0).source;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      return esProduct;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public EsProduct produSkuInfo(Long id) &#123;</span><br><span class="line">      EsProduct esProduct &#x3D; null;</span><br><span class="line">      &#x2F;&#x2F;按照id查出商品</span><br><span class="line">      SearchSourceBuilder builder &#x3D; new SearchSourceBuilder();</span><br><span class="line">      builder.query(QueryBuilders.nestedQuery(&quot;skuProductInfos&quot;,QueryBuilders.termQuery(&quot;skuProductInfos.id&quot;,id), ScoreMode.None));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Search build &#x3D; new Search.Builder(builder.toString())</span><br><span class="line">              .addIndex(EsConstant.PRODUCT_ES_INDEX)</span><br><span class="line">              .addType(EsConstant.PRODUCT_INFO_ES_TYPE)</span><br><span class="line">              .build();</span><br><span class="line">      try &#123;</span><br><span class="line">          SearchResult execute &#x3D; jestClient.execute(build);</span><br><span class="line"></span><br><span class="line">          List&lt;SearchResult.Hit&lt;EsProduct, Void&gt;&gt; hits &#x3D; execute.getHits(EsProduct.class);</span><br><span class="line">          esProduct &#x3D; hits.get(0).source;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      return esProduct;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>数据成功检索，只不过前端没有解析</p>
<p><img src="https://img-blog.csdnimg.cn/20201203160029167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwNDM5Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;8s  2.5s； 需要速度快。 开启异步化 最多1s，取决最长的服务调用。</span><br><span class="line">&#x2F;&#x2F;高并发系统的优化</span><br><span class="line">&#x2F;&#x2F;1、加缓存</span><br><span class="line">&#x2F;&#x2F;2、开异步</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85/" data-id="ckib1p4bz000440u1hif54x7i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（14）缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2020-12-05T01:48:37.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89%E7%BC%93%E5%AD%98/">学习笔记（14）缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p>问题：</p>
<p>查询频率高，数据变化率是不是太快了，我们进缓存，缓存与数据库不同步。因此，存在一个悖论，到底是变化频率高还是变化频率低的进缓存。</p>
<p>我们读取数据的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(readLock)&#123;</span><br><span class="line"></span><br><span class="line">	Data data &#x3D; readFromCache();</span><br><span class="line"></span><br><span class="line">	if(data &#x3D;&#x3D; null)&#123;</span><br><span class="line"></span><br><span class="line">		data &#x3D; readFromDb();</span><br><span class="line"></span><br><span class="line">        setToCache(data);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写数据的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(writeLock)&#123;</span><br><span class="line"></span><br><span class="line">	Data data &#x3D; xxxxx;</span><br><span class="line"></span><br><span class="line">	updateDataToDb(data);</span><br><span class="line"></span><br><span class="line">	setTocache(data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双写（数据库写，缓存写都成功才算成功，两个方法写到一个service里，加上事务）保证一致性；</p>
<p>细节：</p>
<p>1） 最终一致性：</p>
<p>下单，查看价时要完全看最新价格，我们读锁。商品详情页看价格，直接去缓存中读取，不加读锁。</p>
<p>双写+读写锁保持一致性，还有失效模式；</p>
<p>缓存使用模式分为两大类：Cache-Aside和Cache As SoR</p>
<p>专业名词：</p>
<p>SoR（system-of-record）：记录系统，或者可以叫数据源，实际存储原始数据的系统</p>
<p>Cache：缓存，是SoR的快照数据，Cache的访问速度比SoR要快，放入Cache的目的是提升系统速度，减少回源到SoR的次数</p>
<p>回源：回到数据源头检索数据，Cache没有命中需要回到SoR读取数据，这叫做回源</p>
<p>缓存命中：缓存命中率越高：这个数据在缓存中有，这个数据越被高频率检索</p>
<h2 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache-Aside"></a>Cache-Aside</h2><p>并发更新问题：100万请求进来改数据库，18号最后CPU轮到改了数据库为19，但是改缓存时确实第一个轮到，这样数据库的记录为18号，但是缓存的记录不是18号。</p>
<p>解决：1）写加写锁</p>
<p>2）canal伪装成mysql的从库，从数据库读取binlog日志，用该日志改缓存</p>
<p>3）读服务，可以考虑一致性哈希，相同的操作负载均衡到同一个实例，从而减少并发几率。缓存让同一个读写方法都去同一个缓存，减少并发几率。</p>
<h2 id="Cache-As-SoR"><a href="#Cache-As-SoR" class="headerlink" title="Cache As SoR"></a>Cache As SoR</h2><p>可使用AOP实现：读之前先读缓存，写之后再写缓存，抽取出来</p>
<p>即把Cache当做SoR，所有操作都是对Cache进行，然后Cache委托SoR进行数据的真实读写。即业务代码只看到Cache的操作，看不到关于SoR的代码；三种实现模式：read-through、write-through、write-behind<br>缓存框架： 配置好哪些类的数据对应哪个数据库的哪张表.</p>
<p>| read-through</p>
<p>业务代码首先调用Cache，Cache不命中，由Cache回源到SoR（类似回调的方式或者Cache配置的方式），而不是业务代码。【Guava、Ehcache均支持这种模式】</p>
<p>优点：业务代码整洁</p>
<p>缺点：屏蔽了底层数据库的操作，定制性不强</p>
<p>l write-through</p>
<p>称为穿透写模式/直写模式。业务代码调用Cache写数据，然后由Cache负责写缓存和写SoR，而不是业务代码。</p>
<p>l write-behind</p>
<p>也叫write-back；回写模式。不同于write-through的是，write-through是同步写，而write-back是异步写，异步成功后可以实现批量写、合并写、延时写等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89%E7%BC%93%E5%AD%98/" data-id="ckib1p4bx000240u16jia8wqi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记（13）分布式锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time datetime="2020-12-05T01:47:24.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">学习笔记（13）分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>

<p>分布式锁</p>
<p>以前的锁：进程内锁<br>进程间锁需要使用分布式锁<br>RPC解决进程间通信问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">StringRedisTemplate redisTemplate</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;public Object obj &#x3D; new Object();</span><br><span class="line">public void incr()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个锁大家都用一个。</span><br><span class="line">        &#x2F;&#x2F;this当前对象。当前service对象。spring的组件是单例的。this一个。</span><br><span class="line">        &#x2F;&#x2F;this相同，锁相同，锁ok</span><br><span class="line">        &#x2F;&#x2F;RedisIncrService对象一个。自动注入；StringRedisTemplate，redisTemplate也只能注入唯一一个。</span><br><span class="line">        &#x2F;&#x2F;RedisIncrService对象创建的时候赋值，RedisIncrService一个   private Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1）、synchronized(this)：能</span><br><span class="line">        &#x2F;&#x2F;2）、synchronized (redisTemplate)：能</span><br><span class="line">        &#x2F;&#x2F;3）、synchronized (new Object())：锁不住</span><br><span class="line">        &#x2F;&#x2F;4）、synchronized (obj)：锁得住？锁得住 &#x2F;RedisIncrService对象创建的时候赋值，RedisIncrService一个   private Object obj &#x3D; new Object();System.out.println(obj.hashcode()),hashcode都一样</span><br><span class="line">        &#x2F;&#x2F;5）、synchronized (obj())；锁的住</span><br><span class="line">        &#x2F;&#x2F;6）、synchronized (RedisIncrService.class)；锁得住, 万物皆对象，从头到尾传的是RedisIncrService这个类型，JVM虚拟机里一个类型只有一个在专门存类的元数据区域。</span><br><span class="line"></span><br><span class="line">	synchronized (this)&#123;</span><br><span class="line">	ValueOperations&lt;String, String&gt; stringStringValueOperations &#x3D; redisTemplate.opsForValue();</span><br><span class="line">	String num &#x3D; stringStringValueOperations.get(&quot;num&quot;);</span><br><span class="line">	if(num!&#x3D;null)&#123;</span><br><span class="line">		Integer i &#x3D; Integer.parseInt(num);                i &#x3D; i+1;</span><br><span class="line">	   stringStringValueOperations.set(&quot;num&quot;,i.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5)</span><br><span class="line">    public Object obj() &#123;</span><br><span class="line">       </span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;肯定锁不住</span><br><span class="line">    public Object obj() &#123;</span><br><span class="line">        Object o &#x3D; new Object();</span><br><span class="line">        BeanUtils.copyProperties(obj, o);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line">    public RedisAutoConfiguration() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">        name &#x3D; &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;</span><br><span class="line">        StringRedisTemplate template &#x3D; new StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;StringRedisTemplate 容器放入一个，是单例</span><br><span class="line">    &#x2F;&#x2F;ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">    public void incr() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  ReentrantLock lock &#x3D; new ReentrantLock();应该在成员变量位置才锁得住，&#x2F;&#x2F;也即放到方法外，自始至终只有一个锁</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;锁得住？</span><br><span class="line">        lock.lock();</span><br><span class="line">        ValueOperations&lt;String, String&gt; stringStringValueOperations &#x3D; redisTemplate.opsForValue();</span><br><span class="line">        String num &#x3D; stringStringValueOperations.get(&quot;num&quot;);</span><br><span class="line">        if (num !&#x3D; null) &#123;</span><br><span class="line">            Integer i &#x3D; Integer.parseInt(num);</span><br><span class="line">            i &#x3D; i + 1;</span><br><span class="line">            stringStringValueOperations.set(&quot;num&quot;, i.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上 进程内肯定好使，单机跑。分布式肯定 不好使</p>
<p>分布式锁的原理，为了获取同一把锁，大家都去redis里拿锁</p>
<p>在redis里设置lock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">        *</span><br><span class="line">        * setnx-&gt;set if not exist：原子操作。判断带保存。</span><br><span class="line">        *</span><br><span class="line">        *1）、代码第一阶段；</span><br><span class="line">        * public void hello()&#123;</span><br><span class="line">        *</span><br><span class="line">        * &#x2F;&#x2F;获取和设置值必须是原子的9</span><br><span class="line">        *   String lock &#x3D;  getFromRedis(&quot;lock&quot;);&#x2F;&#x2F;get(&quot;lock&quot;)</span><br><span class="line">        *   if(lock &#x3D;&#x3D; null)&#123;</span><br><span class="line">        *       setRedisKey(&quot;lock&quot;,&quot;1&quot;);</span><br><span class="line">        *       &#x2F;&#x2F;执行业务</span><br><span class="line">        *       delRedisKey(&quot;lock&quot;)</span><br><span class="line">        *       return ;</span><br><span class="line">        *   &#125;else&#123;</span><br><span class="line">        *      hello();&#x2F;&#x2F;自旋</span><br><span class="line">        *   &#125;</span><br><span class="line">        * &#125;</span><br><span class="line">        * &#x2F;&#x2F;问题：加锁的原子性</span><br><span class="line">        *</span><br><span class="line">        * 2、代码第二阶段</span><br><span class="line">        * public void hello()&#123;</span><br><span class="line">        *     &#x2F;&#x2F;1、获取到锁</span><br><span class="line">        *     Integer lock &#x3D; setnx(&quot;lock&#39;,&quot;111&quot;); &#x2F;&#x2F;0代表没有保存数据，说明已经有人占了。1代表占可坑成功</span><br><span class="line">        *     if(lock!&#x3D;0)&#123;</span><br><span class="line">        *         &#x2F;&#x2F;执行业务逻辑</span><br><span class="line">        *         &#x2F;&#x2F;释放锁、删除锁</span><br><span class="line">        *         del(&quot;lock&quot;)</span><br><span class="line">        *     &#125;else&#123;</span><br><span class="line">        *         &#x2F;&#x2F;等待重试</span><br><span class="line">        *         hello();</span><br><span class="line">        *     &#125;</span><br><span class="line">        * &#125;</span><br><span class="line">        * &#x2F;&#x2F;问题：如果由于各种问题（未捕获的异常、断电等）导致锁没释放。其他人永远获取不到锁。</span><br><span class="line">        * &#x2F;&#x2F;解决：加个过期时间。</span><br><span class="line">        *</span><br><span class="line">        * 3、代码第三阶段</span><br><span class="line">        * public void hello()&#123;</span><br><span class="line">        *    &#x2F;&#x2F;超时和加锁必须原子</span><br><span class="line">        *     Integer lock &#x3D; setnx(&quot;lock&#39;,&quot;111&quot;);</span><br><span class="line">        *     if(lock!&#x3D;null)&#123;</span><br><span class="line">        *         expire(&quot;lock&quot;,10s);</span><br><span class="line">        *         &#x2F;&#x2F;执行业务逻辑</span><br><span class="line">        *         &#x2F;&#x2F;释放锁</span><br><span class="line">        *         del(&quot;lock&#39;)</span><br><span class="line">        *     &#125;else&#123;</span><br><span class="line">        *         hello();</span><br><span class="line">        *     &#125;</span><br><span class="line">        *</span><br><span class="line">        * &#125;</span><br><span class="line">        * 问题：刚拿到锁，机器炸了，没来得及设置超时。</span><br><span class="line">        * 解决：加锁和加超时也必须是原子的。</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        * 4、代码第四阶段：</span><br><span class="line">        * public void hello()&#123;</span><br><span class="line">        *     String result &#x3D; setnxex(&quot;lock&quot;,&quot;111&quot;,10s);</span><br><span class="line">        *     if(result&#x3D;&#x3D;&quot;ok&quot;)&#123;</span><br><span class="line">        *         &#x2F;&#x2F;加锁成功</span><br><span class="line">        *         &#x2F;&#x2F;执行业务逻辑</span><br><span class="line">        *         del(&quot;lock&quot;)</span><br><span class="line">        *     &#125;else&#123;</span><br><span class="line">        *         hello();</span><br><span class="line">        *     &#125;</span><br><span class="line">        * &#125;</span><br><span class="line">        * 问题：如果业务逻辑超时，导致锁自动删除，业务执行完又删除一遍。至少多个人都获取到了锁。</span><br><span class="line">        *</span><br><span class="line">        * 5、代码第五阶段。</span><br><span class="line">        * public void hello()&#123;</span><br><span class="line">        *    String token &#x3D; UUID;</span><br><span class="line">        *    String result &#x3D; setnxex(&quot;lock&quot;,token,10s);</span><br><span class="line">        *    if(result &#x3D;&#x3D; &quot;ok&quot;)&#123;</span><br><span class="line">        *        &#x2F;&#x2F;执行业务</span><br><span class="line">        *</span><br><span class="line">        *        &#x2F;&#x2F;删锁，保证删除自己的锁</span><br><span class="line">        *        if(get(&quot;lock&quot;)&#x3D;&#x3D;token)&#123;</span><br><span class="line">        *            del(&quot;lock&quot;)</span><br><span class="line">        *        &#125;</span><br><span class="line">        *    &#125;else&#123;</span><br><span class="line">        *        hello();</span><br><span class="line">        *    &#125;</span><br><span class="line">        * &#125;</span><br><span class="line">        * 问题？：我们获取锁的时候，锁的值正在给我们返回。锁过期。redis删除了锁。</span><br><span class="line">        * 但是我们拿到了值，而且对比成功（此时此刻正好有人又获取）。我们还删除了锁。至少两个线程又进入同一个代码。</span><br><span class="line">        *  原因：？删锁不是原子。d</span><br><span class="line">        *      lua脚本。</span><br><span class="line">        *</span><br><span class="line">        *  解决：</span><br><span class="line">        *  String script &#x3D;</span><br><span class="line">        *      &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">        *              return redis.call(&#39;del&#39;, KEYS[1])</span><br><span class="line">        *       else</span><br><span class="line">        *              return 0</span><br><span class="line">        *       end&quot;;</span><br><span class="line">        *</span><br><span class="line">        * jedis.eval(script, Collections.singletonList(key), Collections.singletonList(token));</span><br><span class="line">        *</span><br><span class="line">        *   lua脚本进行删除。</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        * 1）、分布式锁的核心（保证原子性）</span><br><span class="line">        *      1）、加锁。占坑一定要是原子的。（判断如果没有，就给redis中保存值）</span><br><span class="line">        *      2）、锁要自动超时。</span><br><span class="line">        *      3）、解锁也要原子。</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *  最终的分布式锁的代码：大家都去redis中占同一个坑。</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *  @Lock</span><br><span class="line">        *  public void hello()&#123;</span><br><span class="line">        *      String token &#x3D; uuid;</span><br><span class="line">        *      String lock &#x3D; redis.setnxex(&quot;lock&quot;,token,10s);</span><br><span class="line">        *      if(lock&#x3D;&#x3D;&quot;ok&quot;)&#123;</span><br><span class="line">        *          &#x2F;&#x2F;执行业务逻辑</span><br><span class="line">        *          &#x2F;&#x2F;脚本删除锁</span><br><span class="line">        *      &#125;else&#123;</span><br><span class="line">        *          hello();&#x2F;&#x2F;自旋。</span><br><span class="line">        *      &#125;</span><br><span class="line">        *  &#125;</span><br><span class="line">        *</span><br></pre></td></tr></table></figure>

<p>redis底层单线程，只要是一条完整命令，就是原子性的，这是redis快的原因。多线程由于线程切换不一定快。</p>
<p>发一个删锁命令，连删锁，对比一起执行。但是redis没有此命令，所以使用redis支持的脚本语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"> String script &#x3D;</span><br><span class="line">         *      &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">         *              return redis.call(&#39;del&#39;, KEYS[1])</span><br><span class="line">         *       else</span><br><span class="line">         *              return 0</span><br><span class="line">         *       end&quot;;</span><br><span class="line">         *</span><br><span class="line">         * jedis.eval(script, Collections.singletonList(key), Collections.singletonList(token));</span><br><span class="line">         &#x2F;&#x2F;如果redis要getlock的值，而且值等于传过来的值，则redis调用删锁命令，否则什么也不执行。</span><br><span class="line">         &#x2F;&#x2F;redis是单线程的，所以以上是原子命令，只有该命令执行后，才可执行其它线程的命令</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean(&#123;RedisConnectionFactory.class&#125;)</span><br><span class="line">JedisConnectionFactory redisConnectionFactory ( ObjectProvider&lt;JedisClientConfigurationBuilderCustomizer&gt; builderCustomizers) throws UnknownHostException &#123;</span><br><span class="line">    return this.createJedisConnectionFactory(builderCustomizers);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;没有RedisConnectionFactory，才配置JedisConnectionFactory </span><br><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods &#x3D; false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><br><span class="line">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="line">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line">    public RedisAutoConfiguration() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">        name &#x3D; &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;</span><br><span class="line">        StringRedisTemplate template &#x3D; new StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;RedisConnectionFactory自动整进来</span><br><span class="line">&#x2F;**</span><br><span class="line">         * 1、锁的更多考虑</span><br><span class="line">         *   1）、自旋。</span><br><span class="line">         *      自旋次数。</span><br><span class="line">         *      自旋超时。</span><br><span class="line">         *   2）、锁设置</span><br><span class="line">         *      锁粒度；细；记录级别；</span><br><span class="line">         *          1）、各自服务各自锁</span><br><span class="line">         *          2）、分析好粒度，不要锁住无关数据。一种数据一种锁，一条数据一个锁。</span><br><span class="line">         *   3）、锁类型：</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         * 查询商品详情；进缓存--&gt;击穿，穿透，雪崩。</span><br><span class="line">         *</span><br><span class="line">         *   查商品</span><br><span class="line">         *   public Product productInfo(String productId)&#123;</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *      Product cache &#x3D; jedis.get(productId);</span><br><span class="line">         *      if(cache!&#x3D;null)&#123;</span><br><span class="line">         *          return cache;</span><br><span class="line">         *      &#125;else&#123;</span><br><span class="line">         *          &#x2F;&#x2F;各自数据各自锁。</span><br><span class="line">         *          String lock &#x3D; jedis.set(&quot;lock-&quot;+productId, token, SetParams.setParams().ex(3).nx());</span><br><span class="line">         *          if(lock!&#x3D;null)&#123;</span><br><span class="line">         *             &#x2F;&#x2F;查数据库</span><br><span class="line">         *              Product product &#x3D; getFromDb();</span><br><span class="line">         *              jedis.set(productId,product);</span><br><span class="line">         *          &#125;else&#123;</span><br><span class="line">         *              return productInfo(productId);&#x2F;&#x2F;自旋。</span><br><span class="line">         *          &#125;</span><br><span class="line">         *      &#125;</span><br><span class="line">         *   &#125;</span><br><span class="line">         *</span><br><span class="line">         *   查询1号商品，2,3,4,5，6；</span><br><span class="line">         *   1号商品缓存没有，2号有，3号没有，4没有，5有。</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *      jedis.set(&quot;lock&quot;, token, SetParams.setParams().ex(3).nx());</span><br><span class="line">         *      if()&#123;</span><br><span class="line">         *          &#x2F;&#x2F;拿到锁</span><br><span class="line">         *      &#125;</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br></pre></td></tr></table></figure>

<p>可重入锁，意义·：同样一个线程，在内部，外部，内内部获取锁，都是同一把锁，不会造成死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean lock() &#123;</span><br><span class="line">    RLock lock &#x3D; redisson.getLock(&quot;lock&quot;);</span><br><span class="line">    &#x2F;&#x2F;lock.lock();&#x2F;&#x2F;默认是阻塞的。</span><br><span class="line">    &#x2F;&#x2F;lock.tryLock()；是非阻塞的，尝试一下，拿不到就算了。</span><br><span class="line">    &#x2F;&#x2F;boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);等待100s内只要能获取到锁，这个锁就10秒超时，</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(&quot;第一次锁&quot;);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(&quot;第二次锁&quot;);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(&quot;第三次锁&quot;);</span><br><span class="line">    &#x2F;&#x2F;这个线程的任意期间都要获取这把锁，是直接使用的。说明这个锁是可重入锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return  lock.tryLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;哪个线程加的锁一定要在这个线程解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;加锁</span><br><span class="line">    &#x2F;&#x2F;业务</span><br><span class="line">    &#x2F;&#x2F;解锁</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="ckib1p4by000340u1g9abat4k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8822%EF%BC%89%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/">学习笔记（22）订单服务</a>
          </li>
        
          <li>
            <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8821%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">学习笔记（21）消息队列</a>
          </li>
        
          <li>
            <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">学习笔记（20）分布式事务</a>
          </li>
        
          <li>
            <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8819%EF%BC%89%E8%B4%AD%E7%89%A9%E8%BD%A6/">学习笔记（19）购物车&#34;</a>
          </li>
        
          <li>
            <a href="/2020/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8818%EF%BC%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">学习笔记（18）单点登录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>